<!DOCTYPE html>
<html>
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.15.0/d3.min.js"></script>
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3-tip/0.9.1/d3-tip.min.js"></script>
</head>

<body style="padding:0px;margin:0px;">
	<div id="divbody"  style="text-align:center;width:100%;">
		<div style="width:100%;position: fixed;background-color: white; height: 50px;padding: 10px 0px 10px 0px;z-index: 100">
			<div style="margin: auto;">
			<span style="color: steelblue;font-size: 18px;font-weight: bold;display: inline;">Debates</span>&nbsp;&nbsp;
			<button id=btnFirstDebate class="btnDebate btnDebateSelected" event="First_debate" eventid="0">1</button>&nbsp;&nbsp;
			<button id=btnSecondDebate class="btnDebate btnDebateBelow" event="Second_debate" eventid="1">2</button>&nbsp;&nbsp;		
			<button id=btnThirdDebate class="btnDebate btnDebateBelow" event="Third_debate" eventid="2">3</button id=btnSecondDebate>&nbsp;&nbsp;
			<button id=btnFourthDebate class="btnDebate btnDebateBelow" event="Fourth_debate" eventid="3">4</button id=btnThirdDebate>&nbsp;&nbsp;
			<button id=btnLastDebate class="btnDebate btnDebateBelow" event="Before_Election" eventid="4">5</button>
			</div>
			<hr>
		</div>
		<div style="width:100%;padding-top:60px;">
			<div style="display: inline-block;height:300px;vertical-align: top;position: relative;">
				<div id="TopThemeGraph" style="margin:10px auto;width:100%;">
					<div style="position:absolute;top:50%;left: 50%;width: 100%; height: 100%;" class="loaderContainer">
						<div class="loader"></div>
					</div>
				</div>
			</div>
			<div style="display: inline-block;height:300px;">
				<div style="margin:30px auto 0px auto; width: 200px;">
					<div>Swing State 1</div>
					<svg id="svgSwingStateGraph1" width="200" height="60" style="min-height: 60px;"></svg>
					<div>Swing State 2</div>
					<svg id="svgSwingStateGraph2" width="200" height="60" style="min-height: 60px;"></svg>
					<div>Swing State 3</div>
					<svg id="svgSwingStateGraph3" width="200" height="60" style="min-height: 60px;"></svg>
				</div>
			</div>
		</div>
		<div id='divPolaritySubjectivity' style="width:100%;padding-top:60px;">
			<div id="divLineChartGraph" style="display:inline-block;position:relative;">
				<div id="divNumberDisplay" style="position:relative;margin-bottom:-30px;width:20%;padding-left: 30px;">
					<label class="container">Number
						<input id="cbShowNumber" type="checkbox" checked="checked">
						<span class="checkmark"></span>
					</label>
				</div>
				<div style="position:absolute;top:50%;left: 50%;width: 100%; height: 100%;" class="loaderContainer">
					<div class="loader"></div>
				</div>
			</div>
			<div id="TrumpAndHillaryGraph" style="text-align:left;display:inline-block;padding:10px 0 0 10px;vertical-align: top;width:360px;">
				<table>
					<tr>
						<td style="width: 60px;padding-bottom: 2em;padding-right:40px;">

						</td>
						<td style="width: 80px;text-align: center;padding-bottom: 2em;padding-right:40px;">
							<button class="btnSentiment btnSentimentSelected" event="overall_polarity" id="PolarityButton">Polarity</button>
						</td>
						<td style="width: 80px;text-align: center;padding-bottom: 2em;padding-right:40px;">
							<button class="btnSentiment" event="overall_subjectivity"  statsid="2" id="SubjectivityButton">Subjectivity</button>
						</td>
					</tr>
					<tr style="height: 140px;">
						<td style="width: 60px;padding-bottom: 2em;padding-right: 40px;height: 120px;">
							<img src="images/Trump.jpg" id="imgTrumpLine" width="40" height="40" class="LineChartImage LineChartImageSelectedTrump TrumpSurround" style="vertical-align: bottom;">
						</td>
						<td style="width: 80px;text-align: center;padding-right:40px;" class="TrumpPsGraph">
							<div style="width: 75px;margin: auto;height: 100%;padding:10px 0px;border-radius: 5px;height: 120px;" class="PolarityCell">
								<label class="displayNumber" id="lbTrumpPolarity" style="color:green;font-weight: bold;" ></label>
								<span class="spanTrumpPolarity" style="float: right;"></span>
							</div>
						</td>
						<td style="width: 80px;text-align: center;padding-right:40px;" class="TrumpPsGraph">
							<div style="width: 120px;margin: auto;height: 100%;padding:10px 0px;border-radius: 5px;" class="SubjectivityCell">
								<!-- <label class="displayNumber" id="lbTrumpSubjectivity" style="color:green;font-weight: bold;"></label> -->
								<svg id="fillgaugeTrumpSubjectivity" width="97%" height="100"></svg>
							</div>
						</td>
					</tr>
					<tr style="height: 140px;">
						<td style="width: 60px;padding-right:40px;padding-right:40px;height: 120px;">
							<img src="images/Hillary.jpg" id="imgHillaryLine" width="40" height="40" class="LineChartImage LineChartImageSelectedHillary HillarySurround" style="vertical-align: bottom;">
						</td>
						<td  style="text-align: center;width: 80px;padding-right:40px;" class="HillaryPsGraph">
							<div style="width: 75px;margin: auto;height: 100%;padding:10px 0px;border-radius: 5px;height: 120px;" class="PolarityCell">
								<label class="displayNumber" id="lbHillaryPolarity" style="color:orange;font-weight: bold;"></label>
								<span class="spanHillaryPolarity" style="float: right;"></span>
							</div>
						</td>
						<td  style="text-align: center;width: 80px;padding-right:40px;" class="HillaryPsGraph">
							<div style="width: 120px;margin: auto;height: 100%;padding:10px 0px;border-radius: 5px;" class="SubjectivityCell">
								<!-- <label class="displayNumber" id="lbHillarySubjectivity" style="color:orange;font-weight: bold;"></label> -->
								<svg id="fillgaugeHillarySubjectivity" width="97%" height="100"></svg>
							</div>
						</td>
					</tr style="height: 150px;">
				</table>
			</div>
		</div>
	</div>

<script>	
	function WindowScreen(){
		return $(window).width();
	}

	function IsMobileDevice(){
		return WindowScreen() < 650
	}

	var cachedData;
	var cachedtopthemes;

	//GenerateLineGraph - start
	var totalWidthLine = 600;
	if(IsMobileDevice()) {
		totalWidthLine =  WindowScreen() * 0.9
	}

	var totalHeightLine = totalWidthLine * 0.55;

	var marginLine = { top: totalWidthLine * 0.1, right: totalWidthLine * 0.06, bottom: totalWidthLine * 0.045, left: totalWidthLine * 0.06 };
	var widthLine = totalWidthLine - marginLine.right - marginLine.left;
	var heightLine = totalHeightLine - marginLine.top - marginLine.bottom;

	var lineGraph = d3
		.select('#divLineChartGraph')
		.append('svg')
		.attr('width', widthLine + marginLine.right + marginLine.left)
		.attr('height', heightLine + marginLine.top + marginLine.bottom)
		.append('g')
		.attr('transform', `translate(${marginLine.left}, ${marginLine.top})`);

	var headerLine = lineGraph
		.append('g')
		.attr('class', 'line-header')
		.attr('transform', `translate(0,${-marginLine.top})`)
		.append('text')
		.attr('font-weight','bold')
		.append('tspan')
		.attr('x', widthLine/2 - 70)
		.attr('dy', '1.0em')
		.style('font-size', '1.0em')
		.style('fill', 'steelblue');

	headerLine.text('Sentiment Overall');

	var  xScaleLine = d3
		.scaleBand()
		.rangeRound([0, widthLine])
		.paddingInner(0.25);

	var yScaleLine = d3
		.scaleLinear()
		.range([heightLine, 0]);

	var xAxisLine = d3
		.axisBottom(xScaleLine)
		.ticks(5)
		.tickSizeInner(5)
		.tickSizeOuter(0);

	var yAxisLine = d3.axisLeft(yScaleLine).tickSize(0);

	var xAxisDrawLine = lineGraph
			.append('g')
			.attr("id", "xaxisDrawLine")
			.attr('class', 'x_axis')
			.attr('transform', `translate(0 ${heightLine})`);

	var yAxisDrawLine = lineGraph.append('g').attr('class', 'y axis');

	var lineCircles = lineGraph.append('g').attr('class', 'lineCircles');

	var linePaths = lineGraph.append('g').attr('class', 'linePaths');

	var tip = d3.tip().attr('class', 'd3-tip').html( d => displayToolTip(d));
	tip.offset([-10, 0])
	var svg = d3.select('body').append('svg').call(tip);

	var	lineCircleBarsTrump = lineCircles.append('g').attr('class', 'lineCircleBarsTrump');
	var	lineCirclesTrump = lineCircles.append('g').attr('class', 'lineCirclesTrump');
	var linePathsTrump = lineCircles.append('g').attr('class', 'linePathsTrump');
	var lineTextsTrump = lineCircles.append('g').attr('class', 'lineTextsTrump');
	var lineNumbersTrump = lineCircles.append('g').attr('class', 'lineNumbersTrump');

	var lineCirclesHillary = lineCircles.append('g').attr('class', 'lineCirclesHillary');
	var linePathsHillary = lineCircles.append('g').attr('class', 'linePathsHillary');
	var lineTextsHillary = lineCircles.append('g').attr('class', 'lineTextsHillary');
	var lineNumbersHillary = lineCircles.append('g').attr('class', 'lineNumbersHillary');

	function GenerateLineGraph(dataSet, firstLoad = false) {
		var selectBtns = $('.btnSentimentSelected');

		if(selectBtns.length != 1){
			return;
		}

		var eventName = selectBtns.attr('event');
		var title = eventName.replace('_', ' ');
		headerLine.text(title.toUpperCase()).attr('transform', `translate(0, -5)`);

		var dataTrump = dataSet.filter(f => f.candidate == 'Trump').map(d => ({ event:d.event, score:d[eventName], name: "Trump"}));
		var dataHillary = dataSet.filter(f => f.candidate == 'Hillary').map(d => ({ event:d.event, score:d[eventName], name: "Hillary"}));

		yScaleLine.domain([d3.min(dataSet, d => d[eventName]), d3.max(dataSet, d => d[eventName])]);

		xScaleLine.domain(dataSet.map(d => d.event));

		var numberRange = d3
			.line()
			.x(d => xScaleLine(d.event))
			.y(d => yScaleLine(d.score))
            .curve(d3.curveMonotoneX);

        var dur = 1000;

		var durPath = 500;
		var delay = 700;
		var tPath = d3.transition().duration(durPath).delay(delay);
		var tDelay = d3.transition().delay(delay);
		var tFast =  d3.transition(100).delay(50);
        var t = d3.transition().duration(dur);
        var tSlow = d3.transition().duration(dur).delay(delay);

		yAxisDrawLine.transition(t).call(yAxisLine.scale(yScaleLine));

		var getLinChartData = (d, i, dataSet) =>
		{
			var eventid = +d3.selectAll('.btnDebateSelected').attr('eventid');
			return {
			    Color: i ==  eventid ? (d.name == 'Trump'? 'green' : 'orange') : 'black',
				FontWeight:i == eventid ? 'bold' : 'normal',
				FontSize:i == eventid ? '14px' : '12px',

				Radius: i == eventid ? 10 : 5,

				TextOpacity: i == dataTrump.length - 1 ? 1 : 0,

				BarChartOpacity:i == eventid ? 0.1 : 0,
			}
		}

		lineCircleBarsTrump
			.selectAll('.lineCircleBar')
			.data(dataTrump, d => d.event)
			.join(
				enter => {
					enter
						.append('rect')
						.attr('class', d => 'lineCircleBar lineCircleBar' + d.event.replace(' ', '_'))
						.attr('x', d => xScaleLine(d.event))
						.attr('y', -30)
						.attr('width', xScaleLine.bandwidth())
						.style('fill', 'lightcyan')
						.style("opacity", (d, i) => getLinChartData(d, i, dataSet).BarChartOpacity)
						.attr('height', totalHeightLine - 55)
						.transition(t)
						.style('fill', 'steelblue');
				},

				update => {
					update
						.transition(t)
						.style("opacity", (d, i) => getLinChartData(d, i, dataSet).BarChartOpacity)
						.attr('x', d => xScaleLine(d.event))
				},

				exit => {
				}
			);

		lineCirclesTrump
			.selectAll('.lineCircleTrump')
			.data(dataTrump, d => d.event)
			.join(
				enter => {
					enter
						.append('circle')
						.style('fill',  'white')
						.attr("cx", d => xScaleLine(d.event) + xScaleLine.bandwidth()/2)
						.attr("cy", d => yScaleLine(d.score))
						.attr('class', d => 'lineCircle lineCircleTrump lineCircle' + d.event.replace(' ', '_'))
						.transition(t)
						.attr("r", (d, i) => getLinChartData(d, i, dataTrump).Radius)
						.style('fill',  'green');
				},

				update => {
					update
						.transition(t)
						.attr("cy", d => yScaleLine(d.score))
						.attr("r", (d, i) => getLinChartData(d, i, dataTrump).Radius)
				},

				exit => {
				}
			);

		linePathsTrump
			.selectAll('.linePathTrump')
				.data(dataTrump, d => d.event)
				.join(
					enter => {
						enter
							.append('path')
							.attr('class', 'linePathTrump')
							.attr('d', numberRange(dataTrump))
							.attr('transform', `translate(${marginLine.left + totalWidthLine * 0.01}, 0)`)
							.style('fill', 'none')
							.style('stroke', 'none')
							.transition(tFast)
							.style('stroke',  'green');
					},

					update => {
						update
							.transition(t)
							.attr('d', numberRange(dataTrump))
					},

					exit => {
						exit
							.transition(t)
							.remove()
					}
				);

		lineTextsHillary
			.selectAll('.lineTextHillary')
			.data(dataHillary, d => d.event)
			.join(
				enter => {
					enter
						.append("text")
						.attr('class', 'lineTextHillary lineTextSelected')
						.attr("x", d => xScaleLine(d.event) + xScaleLine.bandwidth()/2 + 10)
						.attr("y", d => yScaleLine(d.score) - 5)
						.text("Hillary")
						.attr("stroke", "white")
						.style("opacity", (d, i) => getLinChartData(d, i, dataTrump).TextOpacity)
						.transition(tFast)
						.attr('stroke',  'orange')
				},

				update => {
					update
						.transition(t)
						.attr("y", d => yScaleLine(d.score) - 5)
				},

				exit => {
					exit
						.transition(t)
						.remove()
				}
			);
		lineTextsTrump
			.selectAll('.lineTextTrump')
			.data(dataTrump, d => d.event)
			.join(
				enter => {
					enter
						.append("text")

						.attr("x", d => xScaleLine(d.event) + xScaleLine.bandwidth()/2 + 10)
						.attr("y", d => yScaleLine(d.score) - 5)
						.text("Trump")
						.attr('class', (d, i) =>  'lineTextTrump lineTextSelected ')
						.attr("stroke", "white")
						.style("opacity", (d, i) => getLinChartData(d, i, dataTrump).TextOpacity)
						.transition(tFast)
						.style('stroke',  'green')
				},

				update => {
					update
						.transition(t)
						.attr("y", d => yScaleLine(d.score) - 5)
				},

				exit => {
					exit
						.transition(t)
						.remove()
				}
			);

		lineNumbersTrump
			.selectAll('.lineNumberTrump')
			.data(dataTrump, d => d.event)
			.join(
				enter => {
					enter
						.append("text")
						.attr('class', d => 'lineNumberTrump lineNumberTrump' + d.event.replace(' ', '_'))
						.attr("x", d => xScaleLine(d.event) + xScaleLine.bandwidth()/2 - 35)
						.attr("y", d => yScaleLine(d.score) - 5)
						.text(d => d.score)
						.style("fill", "white")
						.transition(tFast)
						.style("font-size", (d, i) => getLinChartData(d, i, dataTrump).FontSize)
						.style('fill', (d, i) => getLinChartData(d, i, dataTrump).Color)
						.style("font-weight", (d, i) => getLinChartData(d, i, dataTrump).FontWeight);
				},

				update => {
					update
						.transition(t)
						.attr("y", d => yScaleLine(d.score) - 5)
						.text(d => d.score)
						.style("font-size", (d, i) => getLinChartData(d, i, dataTrump).FontSize)
						.style('fill', (d, i) => getLinChartData(d, i, dataTrump).Color)
						.style("font-weight", (d, i) => getLinChartData(d, i, dataTrump).FontWeight);
				},

				exit => {
					exit
						.transition(t)
						.remove()
				}
			);


		lineCirclesHillary
			.selectAll('.lineCircleHillary')
			.data(dataHillary, d => d.event)
			.join(
				enter => {
					enter
						.append('circle')
						.attr('class',  d => 'lineCircle lineCircleHillary lineCircle' + d.event.replace(' ', '_'))
						.style('fill',  'white')
						.attr('cx', d => xScaleLine(d.event) + xScaleLine.bandwidth()/2)
						.attr('cy', d => yScaleLine(d.score))
						.transition(t)
						.attr('r', (d, i) => getLinChartData(d, i, dataHillary).Radius)
						.style('fill',  'orange')
				},

				update => {
					update
						.transition(t)
						.attr("cy", d => yScaleLine(d.score))
						.attr('r', (d, i) => getLinChartData(d, i, dataHillary).Radius)
				},

				exit => {

				}
			);

		linePathsHillary
			.selectAll('.linePathHillary')
			.data(dataHillary, d => d.event)
			.join(
				enter => {
					enter
						.append('path')
						.attr('class', 'linePathHillary')
						.attr('d', numberRange(dataHillary))
						.attr('transform', `translate(${marginLine.left + totalWidthLine * 0.01}, 0)`)
						.style('fill', 'none')
						.style('stroke', 'none')
						.transition(tFast)
						.style('stroke',  'orange');
				},

				update => {
					update
						.transition(t)
						.attr('d', numberRange(dataHillary))
				},

				exit => {
					exit
						.transition(t)
						.remove()
				}
			);


		lineTextsHillary
			.selectAll('.lineTextHillary')
			.data(dataHillary, d => d.event)
			.join(
				enter => {
					enter
						.append("text")
						.attr('class', 'lineTextHillary lineTextSelected')
						.attr("x", d => xScaleLine(d.event) + xScaleLine.bandwidth()/2 + 10)
						.attr("y", d => yScaleLine(d.score) - 5)
						.text("Hillary")
						.attr("stroke", "white")
						.style("opacity", (d, i) => getLinChartData(d, i, dataTrump).TextOpacity)
						.transition(tFast)
						.attr('stroke',  'orange')
				},

				update => {
					update
						.transition(t)
						.attr("y", d => yScaleLine(d.score) - 5)
				},

				exit => {
					exit
						.transition(t)
						.remove()
				}
			);

		lineNumbersHillary
			.selectAll('.lineNumberHillary')
			.data(dataHillary, d => d.event)
			.join(
				enter => {
					enter
						.append("text")
						.attr('class', d => 'lineNumberHillary lineNumberHillary' + d.event.replace(' ', '_'))
						.attr("x", d => xScaleLine(d.event) + xScaleLine.bandwidth()/2 - 35)
						.attr("y", d => yScaleLine(d.score) - 5)
						.text(d => d.score)
						.style("fill", "white")
						.transition(tFast)
						.style("font-size", (d, i) => getLinChartData(d, i, dataHillary).FontSize)
						.style('fill', (d, i) => getLinChartData(d, i, dataHillary).Color)
						.style("font-weight", (d, i) => getLinChartData(d, i, dataHillary).FontWeight);
				},

				update => {
					update
						.transition(t)
						.attr("y", d => yScaleLine(d.score) - 5)
						.text(d => d.score)
						.style("font-size", (d, i) => getLinChartData(d, i, dataHillary).FontSize)
						.style('fill', (d, i) => getLinChartData(d, i, dataHillary).Color)
						.style("font-weight", (d, i) => getLinChartData(d, i, dataHillary).FontWeight);

				},

				exit => {
					exit
						.transition(t)
						.remove()
				}
			);

		if(firstLoad){
			xAxisDrawLine.transition(t)
				.call(xAxisLine.scale(xScaleLine))
				.selectAll("text")
				.attr("class", 'btnLineChartLabel')
				.attr("id", function(d,i) {return d.replace(' ', '_')})
				.on('end', function (d, i) {
					if(i == 0){
						d3.select('#First_debate').attr('class', 'btnLineChartLabel btnLineChartLabelSelected');
					}
					d3.select(this).on("click", lineChartNodeClick);
				});
		}

	}

	//GenerateLineGraph - end


	//top themes - start

	var totalWidth = 700;
	if(IsMobileDevice()) {
		totalWidth =  WindowScreen() * 0.90
	}

	var totalHeight = totalWidth * 0.4;
	var margin = { top: 50, right: 20, bottom: 20, left: 80 };
	var width = totalWidth - margin.right - margin.left - 100;
	var height = totalHeight - margin.top - margin.bottom;

	var TopThemeGraph = d3
		.select('#TopThemeGraph')
		.append('svg')
		.attr('width', width + margin.right + margin.left)
		.attr('height', height + margin.top + margin.bottom)
		.append('g')
		.attr('transform', `translate(${margin.left}, ${margin.top})`);

	var header = TopThemeGraph
		.append('g')
		.attr('class', 'bar-header')
		.attr('transform', `translate(0,${-margin.top * 0.8})`)
		.append('text')
		.attr('font-weight','bold');

	header
		.append('tspan')
		.attr('x', 0)
		.attr('dy', '1.5em')
		.style('font-size', '0.8em')
		.style('fill', '#555')
		.text('Top 5 Themes');

	var bars = TopThemeGraph.append('g').attr('class', 'bars');

	var xScale = d3.scaleLinear().range([0, width]);
	var yScale = d3
		.scaleBand()
		.rangeRound([0, height])
		.paddingInner(0.25);

	var xAxis = d3
		.axisTop(xScale)
		.ticks(5)
		.tickSizeInner(-height)
		.tickSizeOuter(0);

	var xAxisDraw = TopThemeGraph.append('g').attr('class', 'x axis');

	var yAxis = d3.axisLeft(yScale).tickSize(0);

	var yAxisDraw = TopThemeGraph.append('g').attr('class', 'y axis');

	function GenerateTopThemeGraphChart(dataSet, chartResolve){
		var selectBtns = $('.btnDebateSelected');
		var data;
		if(selectBtns.length == 1){
			var eventName = selectBtns.attr('event');
			data = dataSet[eventName].slice(0, 5)
		}
		else{
			var firstRecord = true

			selectBtns.each(function() {
				var eventName = $(this).attr('event');
				var thisData = dataSet[eventName]

				if(firstRecord){
					data = thisData.slice(0, 5);
					firstRecord = false;
				}
				else{
				}

			});
		}

		xScale.domain([0, d3.max(data, d => d[1])+ 5]);
		yScale.domain(data.map(d => d[0]));

		var dur = 1000;
		var t = d3.transition().duration(dur);

		bars
			.selectAll('.bar')
			.data(data, d => d[0])
			.join(
				enter => {
					enter
						.append('rect')
						.attr('class', 'bar')
						.attr('y', d => yScale(d[0]))
						.attr('height', yScale.bandwidth())
						.style('fill', 'lightcyan')

						.transition(t)
						.style('fill', 'dodgerblue')
						.attr('width', d => xScale(d[1]))
						.on("end", response => {
							if(chartResolve != undefined)
							{
								chartResolve(response)
							}
						})
				},

				update => {
					update
						.transition(t)
						.style('fill', 'dodgerblue')
						.attr('y', d => yScale(d[0]))
						.attr('width', d => xScale(d[1]))
						.on("end", response => {
							if(chartResolve != undefined)
							{
								chartResolve(response)
							}
						})
				},

				exit => {
					exit
						.transition()
						.duration(dur / 2)
						.style('fill-opacity', 0)
						.remove()
						.on("end", response => {
							if(chartResolve != undefined)
							{
								chartResolve(response)
							}
						})
				}

			)

		// Update Axes.
		xAxisDraw.transition(t).call(xAxis.scale(xScale));
		yAxisDraw.transition(t).call(yAxis.scale(yScale));

	}

	//top themes - end


	//GenerateSwingState - start

	var swingState1 = d3.select('#svgSwingStateGraph1');
	var swingState2 = d3.select('#svgSwingStateGraph2');
	var swingState3 = d3.select('#svgSwingStateGraph3');
	var swingImageSize = 50;
	function GenerateSwingState(data, chartResolve) {
		var TrumpStats = data.filter(d => d.candidate == "Trump");
		var selectBtns = $('.btnDebateSelected');

		var eventName = selectBtns.attr('event').replace('_', ' ');
		var TrumpStatsFiltered = TrumpStats.filter(d => d.event == eventName)[0];

		var dur = 400;
		var t = d3.transition().duration(dur);

		var durR = 400;
		var tR = d3.transition().duration(durR).ease(d3.easeBounce).delay(220);

		var durLong = 5000;
		var tLong = d3.transition().duration(durLong);

		var swingState1Promise = () => {
			return new Promise((resolve, reject) => {
				swingState1
					.selectAll('text')
					.data([TrumpStatsFiltered], d => d.swing_state_1)
					.join(
						enter => {
							enter
							.append('text')
							.attr('x', d => d.swing_state_1 == 'Trump' ? -150 : 150)
							//.attr('x', 75)
							.attr('y', 30)
							.text(d => d.swing_state_1 == 'Trump' ? "Trump":"Hillary")
							.attr("stroke", d => d.swing_state_1 == 'Trump' ? "green":"orange")
							.transition(t)
							.attr('x', 75)
							.on("end", response => {
								if(resolve != undefined)
								{
									resolve(response);
								}
							})
						},

						update => {
							update
							.transition(t)
							.attr('x', 75)
							.text(d => d.swing_state_1 == 'Trump' ? "Trump":"Hillary")
							.attr("stroke", d => d.swing_state_1 == 'Trump' ? "green":"orange")
							.on("end", response => {
								if(resolve != undefined)
								{
									resolve(response);
								}
							})
						},

						exit => {
							exit
							.transition(tR)
							.attr("stroke", "tomato")
							.attr('x', d => d.swing_state_1 == 'Trump' ? 0 : 150)
							.remove()
							.on("end", response => {
								if(resolve != undefined)
								{
									resolve(response);
								}
							})
						}
					)
			})
		}

		var swingState2Promise = () => {
			return new Promise((resolve, reject) => {
				swingState2
					.selectAll('text')
					.data([TrumpStatsFiltered], d => d.swing_state_2)
					.join(
						enter => {
							enter
							.append('text')
							.attr('x',  d => d.swing_state_2 == 'Trump' ? -150 : 150)
							.attr('y', 30)
							.text(d => d.swing_state_2)
							.attr("stroke", d => d.swing_state_2 == 'Trump' ? "green":"orange")
							.transition(t)
							.attr('x', 75)
							.on("end", response => {
								if(resolve != undefined)
								{
									resolve(response);
								}
							})
						},

						update => {
							update
							.transition(t)
							.attr('x', 75)
							.text(d => d.swing_state_2)
							.attr("stroke", d => d.swing_state_2 == 'Trump' ? "green":"orange")
							.on("end", response => {
								if(resolve != undefined)
								{
									resolve(response);
								}
							})
						},

						exit => {
							exit
							.transition(tR)
							.attr("stroke", "tomato")
							.attr('x',  d => d.swing_state_2 == 'Trump' ? 0 : 150)
							.remove()
							.on("end", response => {
								if(resolve != undefined)
								{
									resolve(response);
								}
							})
						}
					)
				})
			}

		var swingState3Promise = () => {
			return new Promise((resolve, reject) => {
				swingState3
					.selectAll('text')
					.data([TrumpStatsFiltered], d => d.swing_state_3)
					.join(
						enter => {
							enter
							.append('text')
							.attr('x', d => d.swing_state_3 == 'Trump' ? -150 : 150)
							.attr('y', 30)
							.text(d => d.swing_state_3 == 'Trump' ? "Trump":"Hillary")
							.attr("stroke", d => d.swing_state_3 == 'Trump' ? "green":"orange")
							.transition(t)
							.attr('x', 75)
							.on("end", response => {
								if(resolve != undefined)
								{
									resolve(response);
								}
							})
						},

						update => {
							update
							.transition(t)
							.attr('x', 75)
							.text(d => d.swing_state_3 == 'Trump' ? "Trump":"Hillary")
							.attr("stroke", d => d.swing_state_3 == 'Trump' ? "green":"orange")
							.on("end", response => {
								if(resolve != undefined)
								{
									resolve(response);
								}
							})
						},

						exit => {
							exit
							.transition(tR)
							.attr("stroke", "tomato")
							.attr('x',  d => d.swing_state_3 == 'Trump' ? 0 : 150)
							.remove()
							.on("end", response => {
								if(resolve != undefined)
								{
									resolve(response);
								}
							})
						}
					)
				})
			}

		Promise.all([swingState1Promise() ,swingState2Promise(), swingState3Promise()
		]).then(() => {
			if(chartResolve != null){
				chartResolve();
			}
		});
	 }

	//GenerateSwingState - end


	//subjectivities and polarities - start

	var formatDecimal2 = d3.format(".2f");

	var psFullHeight = 100;
	var psScale = d3.scaleLinear().domain([0.00, 1.00]).range([psFullHeight/2, psFullHeight]); 
	var psScaleNeg = d3.scaleLinear().domain([1.00, 0.00]).range([0, psFullHeight/2]);   
	var psScaleUp = d3.scaleLinear().domain([0.00, 1.00]).range([0.50, 1.00]); 

    var trumpPolarityBar 
		= d3.select('.spanTrumpPolarity').append('svg')
										.style("width", '30px')
										.style("height", psFullHeight + 'px').append('g')

	var hillaryPolarityBar 
		= d3.select('.spanHillaryPolarity').append('svg')
										.style("width", '30px')
										.style("height", psFullHeight + 'px').append('g')

	var liquidTrumpBuilt = false;
	var gaugeconfigSubjectivity;

	var liquidHillaryBuilt = false;
	var gaugeconfigSubjectivityH;

	function GenerateNumberchanges(data){
		var TrumpStats = data.filter(d => d.candidate == "Trump");
		var HillaryStats = data.filter(d => d.candidate == "Hillary");

		var selectBtns = $('.btnDebateSelected');

		if(selectBtns.length > 0 && selectBtns.length == 1){
			var eventName = selectBtns.attr('event').replace('_', ' ');
			var TrumpStatsFiltered = TrumpStats.filter(d => d.event == eventName);
			var HillaryStatsFiltered = HillaryStats.filter(d => d.event == eventName);

		
			ChangeNumber($('#lbTrumpPolarity'), TrumpStatsFiltered[0].overall_polarity);
			ChangeNumber($('#lbHillaryPolarity'), HillaryStatsFiltered[0].overall_polarity);

			//ChangeNumber($('#lbTrumpSubjectivity'), TrumpStatsFiltered[0].overall_subjectivity);
			//ChangeNumber($('#lbHillarySubjectivity'), HillaryStatsFiltered[0].overall_subjectivity);

			if(liquidTrumpBuilt){
				gaugeconfigSubjectivity.update(TrumpStatsFiltered[0].overall_subjectivity * 100)
			}
			else{
				var configSubjectivity = liquidFillGaugeDefaultSettings();
				configSubjectivity.circleColor = "green";
				configSubjectivity.textColor = "black";
				configSubjectivity.waveTextColor = "grey";
				configSubjectivity.waveColor = "#90ee90";
				configSubjectivity.circleThickness = 0.2;
				configSubjectivity.textVertPosition = 0.2;
				configSubjectivity.waveAnimateTime = 1000;
				gaugeconfigSubjectivity= loadLiquidFillGauge("fillgaugeTrumpSubjectivity", TrumpStatsFiltered[0].overall_subjectivity * 100, configSubjectivity);
				liquidTrumpBuilt = true;
			}
	
			if(liquidHillaryBuilt){
				gaugeconfigSubjectivityH.update(HillaryStatsFiltered[0].overall_subjectivity * 100)
			}
			else{
				var configSubjectivityH = liquidFillGaugeDefaultSettings();
				configSubjectivityH.circleColor = "orange";
				configSubjectivityH.textColor = "black";
				configSubjectivityH.waveTextColor = "grey";
				configSubjectivityH.waveColor = "#fed8b1";
				configSubjectivityH.circleThickness = 0.2;
				configSubjectivityH.textVertPosition = 0.2;
				configSubjectivityH.waveAnimateTime = 1000;
				gaugeconfigSubjectivityH= loadLiquidFillGauge("fillgaugeHillarySubjectivity", HillaryStatsFiltered[0].overall_subjectivity * 100, configSubjectivityH);
				liquidHillaryBuilt = true;
			}

			var t = d3.transition().duration(500);

			//Trump Bar
			var gradient = this.svg
				.append('defs')
				.append('svg:linearGradient')
				.attr('id', 'gradient')
				.attr('x1', '100%')
				.attr('y1', '0%')
				.attr('x2', '100%')
				.attr('y2', '100%')
				.attr('spreadMethod', 'pad')

			var lowColor = d3.interpolateGreens(0);
			var highColor = d3.interpolateGreens(0.8);

			var colorScale = d3.scaleSequential(
                (d) => d3.interpolateGreens(psScaleUp(d))
            )   

			gradient.append('stop').attr('offset', '0%').attr('stop-color', highColor).attr('stop-opacity', 1)
			gradient.append('stop').attr('offset', '100%').attr('stop-color', lowColor).attr('stop-opacity', 1)

			var trumpP = parseFloat(parseFloat(TrumpStatsFiltered[0].overall_polarity).toFixed(2));
			var tp = [{tpKey:'theKey', tpValue: trumpP}];
			trumpPolarityBar
				.selectAll('.PSBar')
				.data(tp, d => d.tpKey)
				.join(
					enter => {
						enter
						.append('rect')
						.attr('class', 'PSBar')
						.attr('x', 5)
						.attr("y", 0)
						.attr('height', psFullHeight)
						.attr('width', 20)
						.style('fill', 'url(#gradient)')
					},
			);

			trumpPolarityBar
				.selectAll('.PSMidline')
				.data(tp, d => d.tpKey)
				.join(
					enter => {
						enter
						.append('line')
						.attr('class', 'PSMidline')
						.style("stroke", "red") 
						.attr("x1", -5) 
						.attr("x2", 35)  
						.attr("y1", psFullHeight/2) 
						.attr("y2", psFullHeight/2)
					},
			);

			trumpPolarityBar
				.selectAll('.PSline')
				.data(tp, d => d.tpKey)
				.join(
					enter => {
						enter
							.append('line')
							.attr('class', 'PSline')
							.style("stroke", "black") 
							.attr("x1", -5) 
							.attr("x2", 35)  
							.attr("y1", d => psFullHeight - (d.tpValue > 0.00 ? psScale(d.tpValue) : psScaleNeg(Math.abs(d.tpValue)))) 
							.attr("y2", d => psFullHeight - (d.tpValue > 0.00 ? psScale(d.tpValue) : psScaleNeg(Math.abs(d.tpValue))))
							.transition()
							.on('end', function (d, i) {
								if(d.tpValue > 0.00){
									$('#lbTrumpPolarity').css('color', colorScale(d.tpValue));
								}
								else{
									$('#lbTrumpPolarity').css('color', 'red');
								}
							});
					},

					update => {
						update
							.transition(t)
							.style("stroke", "black") 
							.attr("y1", d => psFullHeight - (d.tpValue > 0.00 ? psScale(d.tpValue) : psScaleNeg(Math.abs(d.tpValue)))) 
							.attr("y2", d => psFullHeight - (d.tpValue > 0.00 ? psScale(d.tpValue) : psScaleNeg(Math.abs(d.tpValue)))) 
							.on('end', function (d, i) {
								if(d.tpValue > 0.00){
									$('#lbTrumpPolarity').css('color', colorScale(d.tpValue));
								}
								else{
									$('#lbTrumpPolarity').css('color', 'red');
								}
							});
					},

					exit => {
					}
				);

			//Hillary Bar
			var gradientH = this.svg
				.append('defs')
				.append('svg:linearGradient')
				.attr('id', 'gradientH')
				.attr('x1', '100%')
				.attr('y1', '0%')
				.attr('x2', '100%')
				.attr('y2', '100%')
				.attr('spreadMethod', 'pad')

			var lowColorH = d3.interpolateOranges(0);
			var highColorH = d3.interpolateOranges(0.8);

			var colorScaleH = d3.scaleSequential(
                (d) => d3.interpolateOranges(psScaleUp(d))
            )   

			gradientH.append('stop').attr('offset', '0%').attr('stop-color', highColorH).attr('stop-opacity', 1)
			gradientH.append('stop').attr('offset', '100%').attr('stop-color', lowColorH).attr('stop-opacity', 1)

			var hillaryP = parseFloat(parseFloat(HillaryStatsFiltered[0].overall_polarity).toFixed(2));
			var th = [{tpKey:'theKey', tpValue: hillaryP}];
			
			hillaryPolarityBar
				.selectAll('.PSBar')
				.data(th, d => d.tpKey)
				.join(
				enter => {
					enter
					.append('rect')
					.attr('class', 'PSBar')
					.attr('x', 5)
					.attr("y", 0)
					.attr('height', psFullHeight)
					.attr('width', 20)
					.style('fill', 'url(#gradientH)');
				},
			);
			
			hillaryPolarityBar
				.selectAll('.PSMidline')
				.data(tp, d => d.tpKey)
				.join(
					enter => {
						enter
						.append('line')
						.attr('class', 'PSMidline')
						.style("stroke", "red") 
						.attr("x1", -5) 
						.attr("x2", 35)  
						.attr("y1", psFullHeight/2) 
						.attr("y2", psFullHeight/2); 
					},
			);

			hillaryPolarityBar
				.selectAll('.PSline')
				.data(th, d => d.tpKey)
				.join(
					enter => {
						enter
							.append('line')
							.attr('class', 'PSline')
							.style("stroke", "black") 
							.attr("x1", -5) 
							.attr("x2", 35)  
							.attr("y1", d => psFullHeight - (d.tpValue > 0.00 ? psScale(d.tpValue) : psScaleNeg(Math.abs(d.tpValue)))) 
							.attr("y2", d => psFullHeight - (d.tpValue > 0.00 ? psScale(d.tpValue) : psScaleNeg(Math.abs(d.tpValue))))
							.transition()
							.on('end', function (d, i) {
								if(d.tpValue > 0.00){
									$('#lbHillaryPolarity').css('color', colorScaleH(d.tpValue));
								}
								else{
									$('#lbHillaryPolarity').css('color', 'red');
								}
							});
					},

					update => {
						update
							.transition(t)
							.style("stroke", "black") 
							.attr("y1",  d => psFullHeight - (d.tpValue > 0.00 ? psScale(d.tpValue) : psScaleNeg(Math.abs(d.tpValue)))) 
							.attr("y2",  d => psFullHeight - (d.tpValue > 0.00 ? psScale(d.tpValue) : psScaleNeg(Math.abs(d.tpValue)))) 
							.on('end', function (d, i) {
								if(d.tpValue > 0.00){
									$('#lbHillaryPolarity').css('color', colorScaleH(d.tpValue));
								}
								else{
									$('#lbHillaryPolarity').css('color', 'red');
								}
							});
					},

					exit => {
					}
				);

		}
		else {

		}

		RefreshStatsColor();
	}

	async function ChangeNumber(element, targetNumber) {
		var baseNumber = parseFloat(parseFloat(element.text() == ""? "0" : element.text()).toFixed(2));
		var targetNumberParsed = parseFloat(parseFloat(targetNumber== ""? "0" : targetNumber).toFixed(2));

		var diffUnit = 0.01;

		var diffTotal = targetNumberParsed - baseNumber;
		if (diffTotal == 0){
			return;
		}
		else if (diffTotal < 0){
			diffUnit = - diffUnit;
		}

		do {
			if(baseNumber < 0){
				element.addClass('displayNumberNegtive');
			}
			else{
				element.removeClass('displayNumberNegtive');
			}
			baseNumber = parseFloat((baseNumber + diffUnit).toFixed(2)); //solve double precision floating point number problem https://www.w3schools.com/js/js_numbers.asp
			element.text(baseNumber.toFixed(2));

			//element.css('top', 100 - baseNumber *100);

			await sleep(1);
		} while (baseNumber != targetNumberParsed);
	}

	function sleep(ms) {
		return new Promise(resolve => setTimeout(resolve, ms));
	}

	//subjectivities and polarities -end

	function ClickLineTextHillary(){
		if(d3.select(this).classed('lineTextSelected'))
		{
			d3.select(this).classed('lineTextSelected', false)
			lineNumbersHillary.style('opacity', 0);

		}
		else {
			d3.select(this).classed('lineTextSelected', true)
			lineNumbersHillary.style('opacity', 1);
		}
	}

	function ClickLineTextTrump(){
		if(d3.select(this).classed('lineTextSelected'))
		{
			d3.select(this).classed('lineTextSelected', false)
			lineNumbersTrump.style('opacity', 0);

		}
		else {
			d3.select(this).classed('lineTextSelected', true)
			lineNumbersTrump.style('opacity', 1);
		}
	}

	function displayToolTip(d){

		var retval = 'aaa';
		var event = d.event;
		var score = d.score;
		var name = d.name;

		var indicator = $('.btnSentimentSelected').attr('event');
		var indicatorName = indicator.split('_')[1];
		var indicatorCamelCase = indicatorName.charAt(0).toUpperCase() + indicatorName.substr(1).toLowerCase()
		var record = cachedData.filter(c => c.event == event && c.candidate == name)[0];

		retval = `
			<div class='tooltipPopup'>
				<div class='tooltipPopupInner'>
					<div style='display:inline-block;vertical-align:top;width:80px;text-align:left;'>

						<img width='50' height='50' src=${name == 'Trump'? "images/Trump.jpg" : "images/Hillary.jpg"}>
						<div sytle ='height:50px;vertical-align:middle;display:inline-block;'>
							<span style='display:inline-block;vertical-align:middle;width:15px;height:15px;border-radius:50%;background-color:${name == 'Trump'? "green" : "orange"}'></span>
							<label style='height:15px;vertical-align:middle;'>${name}</label>
							<br />
							<a target='__blank' style='color:steelblue;' href=${name == 'Trump'? "https://en.wikipedia.org/wiki/Donald_Trump" : "https://en.wikipedia.org/wiki/Hillary_Clinton" } >more...</a>
						</div>
					</div>
					<div style='display:inline-block;'>
						<div>Event: ${event}</div>
						<div>${indicatorCamelCase}: ${score}</div>
						<div>Top Theme 1: ${record.top_theme_1}</div>
						<div>Top Theme 2: ${record.top_theme_2}</div>
						<div>Top Theme 3: ${record.top_theme_3}</div>
						<div>Top Theme 4: ${record.top_theme_4}</div>
						<div>Top Theme 5: ${record.top_theme_5}</div>
						<div>Swing State 1: ${record.swing_state_1}</div>
						<div>Swing State 2: ${record.swing_state_2}</div>
						<div>Swing State 3: ${record.swing_state_3}</div>
					</div>
				</div>
			</div>
		`;

		return retval;
	}

	function lineChartNodeClickPre(d){
		$('.btnDebate').each(function(){
				if($(this).attr('event') == d.replace(' ', '_')){
					$(this).click();
				}
			}
		);
	}

	function lineChartNodeClick(d, resolve = null){

		d3.selectAll('.btnLineChartLabel')
			.each(function(f) {
				var thisElement = d3.select(this);

				if(thisElement.attr('id') == d.replace(' ', '_')){
					setTimeout(function(){
						thisElement.attr('class', 'btnLineChartLabel btnLineChartLabelSelected');
					}, 400);

				}
				else if(thisElement.classed("btnLineChartLabelSelected")){
					setTimeout(function(){
						thisElement.attr('class', 'btnLineChartLabel');
					}, 400);
				}
			}
		);		

		d3.selectAll('.lineCircle' + d.replace(' ', '_')).each(function(f) {
			d3.select(this).attr('r', 10);
		});

		d3.selectAll('.lineCircle').each(function(f) {
			if(!d3.select(this).classed('lineCircle' + d.replace(' ', '_'))){
				d3.select(this).attr('r', 5);
			}
		});

		$('.btnDebate').removeClass('btnDebateSelected');
		$('.btnDebate').each(function(){
				if($(this).attr('event') == d.replace(' ', '_')){
					$(this).addClass('btnDebateSelected');
				}
			}
		);

		var graphPromise = () => {
				return new Promise((resolve, reject) => {
					RefreshGraph(resolve);
			})
		}

		var lineGraphPromise = () => {
				return new Promise((resolve, reject) => {
					RefreshLineGraph();
					resolve();
			})
		}

		Promise.all([graphPromise(), lineGraphPromise()]).then(() => {
			if(resolve != null){
				resolve();
			}
		})
	}

	function mouseoverLineCircle(d) {
		d3.select(this).attr('r', 10);
		tip.show(d, this);
	}

	function mouseoutLineCircle(d) {
		var event = d3.selectAll('.btnDebateSelected').attr('event');
		if(!d3.select(this).classed('lineCircle' + event.replace(' ', '_'))){
			d3.select(this).attr('r', 5);
		}
	}

	function LineChartImageClick(){
		if($(this).hasClass('LineChartImageSelectedTrump')){
			$(this).removeClass('LineChartImageSelectedTrump');

			d3.selectAll('.lineCirclesTrump ').transition().duration(200).attr('opacity', 0);
			d3.selectAll('.linePathsTrump').transition().duration(200).attr('opacity', 0);
			d3.selectAll('.lineTextsTrump').transition().duration(200).attr('opacity', 0);
			d3.selectAll('.lineNumbersTrump').transition().duration(200).attr('opacity', 0);

			$('.TrumpPsGraph').fadeOut();
		}
		else if ($(this).hasClass('TrumpSurround')){
			$(this).addClass('LineChartImageSelectedTrump');

			d3.selectAll('.lineCirclesTrump ').transition().duration(200).attr('opacity', 1);
			d3.selectAll('.linePathsTrump').transition().duration(200).attr('opacity', 1);
			d3.selectAll('.lineTextsTrump').transition().duration(200).attr('opacity', 1);
			d3.selectAll('.lineNumbersTrump').transition().duration(200).attr('opacity', 1);

			$('.TrumpPsGraph').fadeIn();
		}

		if($(this).hasClass('LineChartImageSelectedHillary')){
			$(this).removeClass('LineChartImageSelectedHillary');

			d3.selectAll('.lineCirclesHillary').transition().duration(200).attr('opacity', 0);
			d3.selectAll('.linePathsHillary').transition().duration(200).attr('opacity', 0);
			d3.selectAll('.lineTextsHillary').transition().duration(200).attr('opacity', 0);
			d3.selectAll('.lineNumbersHillary').transition().duration(200).attr('opacity', 0);

			$('.HillaryPsGraph').fadeOut();
		}
		else if ($(this).hasClass('HillarySurround')){
			$(this).addClass('LineChartImageSelectedHillary');

			d3.selectAll('.lineCirclesHillary').transition().duration(200).attr('opacity', 1);
			d3.selectAll('.linePathsHillary').transition().duration(200).attr('opacity', 1);
			d3.selectAll('.lineTextsHillary').transition().duration(200).attr('opacity', 1);
			d3.selectAll('.lineNumbersHillary').transition().duration(200).attr('opacity', 1);

			$('.HillaryPsGraph').fadeIn();
		}
	}

	function cbMutiSelectChange() {
		if($(this).is(':checked'))
		{
			// $('#divSwingStates').fadeOut();
			// $('#divCandidatesStats').fadeOut();

		}
		else {
			// $('#divSwingStates').fadeIn();
			// $('#divCandidatesStats').fadeIn();
			if($('.btnDebateSelected').length > 1){
				var firstSelected = $('.btnDebateSelected')[0];
				$('.btnDebateSelected').removeClass('btnDebateSelected');
				$(firstSelected).addClass('btnDebateSelected');
			}
		}

		RefreshGraph();
	}

	function PopulateSentimentStyle(){
		if($('#SubjectivityButton').hasClass('btnSentimentSelected')){
			$('#PolarityButton').addClass('GreyOut');
			$('#lbTrumpPolarity').addClass('GreyOut');
			$('#lbHillaryPolarity').addClass('GreyOut');

			$('#SubjectivityButton').removeClass('GreyOut');
			//$('#lbTrumpSubjectivity').removeClass('GreyOut');
			//$('#lbHillarySubjectivity').removeClass('GreyOut');
		}
		else{
			$('#PolarityButton').removeClass('GreyOut');
			$('#lbTrumpPolarity').removeClass('GreyOut');
			$('#lbHillaryPolarity').removeClass('GreyOut');

			$('#SubjectivityButton').addClass('GreyOut');
			//$('#lbTrumpSubjectivity').addClass('GreyOut');
			//$('#lbHillarySubjectivity').addClass('GreyOut');
		}
	}

	function btnSentimentClick(){
		$('.btnSentiment').removeClass('btnSentimentSelected');
		$(this).addClass('btnSentimentSelected');

		RefreshStatsColor();

		RefreshLineGraph();

		PopulateSentimentStyle();
	}

	function RefreshStatsColor(){
		if($('#PolarityButton').hasClass('btnSentimentSelected')){
			$('.PolarityCell').addClass('StatesSelected');
			$('.SubjectivityCell').removeClass('StatesSelected');
		}
		else{
			$('.SubjectivityCell').addClass('StatesSelected');
			$('.PolarityCell').removeClass('StatesSelected');
		}
	}

	function RefreshGraph(resolve) {

		const GenerateNumberchangesPromise = () => {
			return new Promise((resolve, reject) => {
				GenerateNumberchanges(cachedData);
				resolve();
			})
		}
		const GenerateSwingStatePromise = () => {
			return new Promise((resolve, reject) => {
				GenerateSwingState(cachedData, resolve);
			})
		}
		const GenerateTopThemeGraphChartPromise = () => {
			return new Promise((resolve, reject) => {
				GenerateTopThemeGraphChart(cachedtopthemes, resolve);
			})
		}

		Promise.all([GenerateNumberchangesPromise(), GenerateSwingStatePromise(), GenerateTopThemeGraphChartPromise()]).then(() => {
			if(resolve != null){
				resolve();
			}
		})
	}

	function RefreshLineGraph(){
		GenerateLineGraph(cachedData);
	}

	function Populate(){
		PopulateSentimentStyle();
	}

	var eventQueue = [];
	var eventQueueProcessing = -1;

	async function btnClick (){
		var event = $(this).attr('event');
		var date = new Date();
		var key = date.getMilliseconds() + date.getSeconds() * 1000;

		if (eventQueue.length > 1) {
			eventQueue[1] = key;
		}
		else {
		 	eventQueue.push(key);
		}

		var eventFinished = false;
		do {
			if(eventQueue.findIndex((element) => element == key) == 0 && eventQueueProcessing != key)
			{
				eventQueueProcessing = key;

				new Promise(function(resolve, reject) {
					lineChartNodeClick(event, resolve);
					eventFinished = true;
				}).then(function(result) {
					eventQueue.shift();
				});
			}
			await sleep(50);
		} while (eventFinished == false);
	}

	var WireUpEvents = () => {

		d3.selectAll('.btnDebate').on('click', btnClick);

		d3.selectAll('.lineCircle').on('click', d => lineChartNodeClickPre(d.event));
		d3.selectAll('.lineCircleBar').on('click', d => lineChartNodeClickPre(d.event));
		d3.selectAll('.btnSentiment').on('click', btnSentimentClick);
		d3.selectAll('.lineCircle').on('mouseover', mouseoverLineCircle);
		d3.selectAll('.lineCircle').on('mouseout', mouseoutLineCircle);
		$('.LineChartImage').on('click', LineChartImageClick);
		$('#cbShowNumber').on('change',
			function()
			{
				if($(this).is(':checked')){
					lineNumbersHillary.transition().duration(200).attr('opacity', 1);
					lineNumbersTrump.transition().duration(200).attr('opacity', 1);
				}
				else {
					lineNumbersHillary.transition().duration(200).attr('opacity', 0);
					lineNumbersTrump.transition().duration(200).attr('opacity', 0);
				}
			}
		);		

		$(window).click(function(e) {
			$('.tooltipPopup').fadeOut();
		});
	}

	function ProcessTopThemes(data) {
		var firstDebateData = data.filter(d => d.event == 'First debate');
		var secondDebateData = data.filter(d => d.event == 'Second debate');
		var thirdDebateData = data.filter(d => d.event == 'Third debate');
		var fourthDebateData = data.filter(d => d.event == 'Fourth debate');
		var lastDebateData = data.filter(d => d.event == 'Before Election');

		var dictFirst = {};
		var dictSecond = {};
		var dictThird = {};
		var dictFourth = {};
		var dictFinal = {};

		processTopThemesDict(firstDebateData, dictFirst);
		processTopThemesDict(secondDebateData, dictSecond);
		processTopThemesDict(thirdDebateData, dictThird);
		processTopThemesDict(fourthDebateData, dictFourth);
		processTopThemesDict(lastDebateData, dictFinal);

		var getSortedArray =
			dict => Object.keys(dict)
						  .map(key => [key.charAt(0).toUpperCase() + key.substr(1).toLowerCase(), dict[key]])
						  .sort((a, b) => (a[1] < b[1]) ? 1 : -1);

		var arrayFirst = getSortedArray(dictFirst);
		var arraySecond = getSortedArray(dictSecond);
		var arrayThird = getSortedArray(dictThird);
		var arrayFourth = getSortedArray(dictFourth);
		var arrayFinal = getSortedArray(dictFinal);

		var retval = {};
		retval['First_debate'] = arrayFirst;
		retval['Second_debate'] = arraySecond;
		retval['Third_debate'] = arrayThird;
		retval['Fourth_debate'] = arrayFourth;
		retval['Before_Election'] = arrayFinal;

		return retval;
	}

	function processTopThemesDict(data, dict){
		for (i = 0; i < data.length; i++){
			var top_theme_1 = data[i].top_theme_1;
			var top_theme_2 = data[i].top_theme_2;
			var top_theme_3 = data[i].top_theme_3;
			var top_theme_4 = data[i].top_theme_4;
			var top_theme_5 = data[i].top_theme_5;
			processTopThemesDictFurter(top_theme_1, dict);
			processTopThemesDictFurter(top_theme_2, dict);
			processTopThemesDictFurter(top_theme_3, dict);
			processTopThemesDictFurter(top_theme_4, dict);
			processTopThemesDictFurter(top_theme_5, dict);
		}
	}

	function processTopThemesDictFurter(topic, dict) {
		if(dict[topic] == undefined){
			dict[topic] = 1;
		}
		else{
			dict[topic] = dict[topic] + 1;
		}
	}

	LoadAllGraphs();
	function LoadAllGraphs(){
		var timelinekey = d3.csv('data/timelinekey.csv',
			rawrow => ({
				event : rawrow['event'],
				candidate: rawrow['candidate'],
				overall_polarity: formatDecimal2(+rawrow['overall_polarity']),
				overall_subjectivity: formatDecimal2(+rawrow['overall_subjectivity']),
				top_theme_1:  rawrow['top_theme_1'],
				top_theme_2:  rawrow['top_theme_2'],
				top_theme_3:  rawrow['top_theme_3'],
				top_theme_4:  rawrow['top_theme_4'],
				top_theme_5:  rawrow['top_theme_5'],
				swing_state_1: rawrow['swing_state_1'],
				swing_state_2: rawrow['swing_state_2'],
				swing_state_3: rawrow['swing_state_3']
			})
		);
		var timelinetopThemes = d3.csv('data/timelinetopthemes.csv',
			rawrow => ({
				event : rawrow['date'],
				state: rawrow['state'],
				top_theme_1: rawrow['top_theme_1'],
				top_theme_2: rawrow['top_theme_2'],
				top_theme_3: rawrow['top_theme_3'],
				top_theme_4: rawrow['top_theme_4'],
				top_theme_5: rawrow['top_theme_5'],
			})
		);
		Promise.all([timelinekey, timelinetopThemes])
			.then(([timelinekeyData, timelinetopThemesData]) => {
				cachedData = timelinekeyData;
				GenerateLineGraph(timelinekeyData, true);
				GenerateNumberchanges(timelinekeyData);
				GenerateSwingState(timelinekeyData);

				var processedRows = ProcessTopThemes(timelinetopThemesData);
				cachedtopthemes = processedRows;
				GenerateTopThemeGraphChart(processedRows);
			})
			.then(
				() => {
						
						$('.loaderContainer').hide();
						WireUpEvents();
						Populate();
					}
				);
	}

/*!
 * @license Open source under BSD 2-clause (http://choosealicense.com/licenses/bsd-2-clause/)
 * Copyright (c) 2015, Curtis Bratton
 * All rights reserved.
 *
 * Liquid Fill Gauge v1.1
 */
function liquidFillGaugeDefaultSettings(){
    return {
        minValue: 0, // The gauge minimum value.
        maxValue: 100, // The gauge maximum value.
        circleThickness: 0.05, // The outer circle thickness as a percentage of it's radius.
        circleFillGap: 0.05, // The size of the gap between the outer circle and wave circle as a percentage of the outer circles radius.
        circleColor: "#178BCA", // The color of the outer circle.
        waveHeight: 0.05, // The wave height as a percentage of the radius of the wave circle.
        waveCount: 1, // The number of full waves per width of the wave circle.
        waveRiseTime: 1000, // The amount of time in milliseconds for the wave to rise from 0 to it's final height.
        waveAnimateTime: 18000, // The amount of time in milliseconds for a full wave to enter the wave circle.
        waveRise: true, // Control if the wave should rise from 0 to it's full height, or start at it's full height.
        waveHeightScaling: true, // Controls wave size scaling at low and high fill percentages. When true, wave height reaches it's maximum at 50% fill, and minimum at 0% and 100% fill. This helps to prevent the wave from making the wave circle from appear totally full or empty when near it's minimum or maximum fill.
        waveAnimate: true, // Controls if the wave scrolls or is static.
        waveColor: "#178BCA", // The color of the fill wave.
        waveOffset: 0, // The amount to initially offset the wave. 0 = no offset. 1 = offset of one full wave.
        textVertPosition: .5, // The height at which to display the percentage text withing the wave circle. 0 = bottom, 1 = top.
        textSize: 1, // The relative height of the text to display in the wave circle. 1 = 50%
        valueCountUp: true, // If true, the displayed value counts up from 0 to it's final value upon loading. If false, the final value is displayed.
        displayPercent: true, // If true, a % symbol is displayed after the value.
        textColor: "#045681", // The color of the value text when the wave does not overlap it.
        waveTextColor: "#A4DBf8" // The color of the value text when the wave overlaps it.
    };
}

function loadLiquidFillGauge(elementId, value, config) {
    if(config == null) config = liquidFillGaugeDefaultSettings();

    var gauge = d3.select("#" + elementId);
    var radius = Math.min(parseInt(gauge.style("width")), parseInt(gauge.style("height")))/2;
    var locationX = parseInt(gauge.style("width"))/2 - radius;
    var locationY = parseInt(gauge.style("height"))/2 - radius;
    var fillPercent = Math.max(config.minValue, Math.min(config.maxValue, value))/config.maxValue;

    var waveHeightScale;
    if(config.waveHeightScaling){
        waveHeightScale = d3.scaleLinear()
            .range([0,config.waveHeight,0])
            .domain([0,50,100]);
    } else {
        waveHeightScale = d3.scaleLinear()
            .range([config.waveHeight,config.waveHeight])
            .domain([0,100]);
    }

    var textPixels = (config.textSize*radius/2);
    var textFinalValue = parseFloat(value).toFixed(2);
    var textStartValue = config.valueCountUp?config.minValue:textFinalValue;
    var percentText = config.displayPercent?"%":"";
    var circleThickness = config.circleThickness * radius;
    var circleFillGap = config.circleFillGap * radius;
    var fillCircleMargin = circleThickness + circleFillGap;
    var fillCircleRadius = radius - fillCircleMargin;
    var waveHeight = fillCircleRadius*waveHeightScale(fillPercent*100);

    var waveLength = fillCircleRadius*2/config.waveCount;
    var waveClipCount = 1+config.waveCount;
    var waveClipWidth = waveLength*waveClipCount;

    // Rounding functions so that the correct number of decimal places is always displayed as the value counts up.
    var textRounder = function(value){ return Math.round(value); };
    if(parseFloat(textFinalValue) != parseFloat(textRounder(textFinalValue))){
        textRounder = function(value){ return parseFloat(value).toFixed(1); };
    }
    if(parseFloat(textFinalValue) != parseFloat(textRounder(textFinalValue))){
        textRounder = function(value){ return parseFloat(value).toFixed(2); };
    }

    // Data for building the clip wave area.
    var data = [];
    for(var i = 0; i <= 40*waveClipCount; i++){
        data.push({x: i/(40*waveClipCount), y: (i/(40))});
    }

    // Scales for drawing the outer circle.
    var gaugeCircleX = d3.scaleLinear().range([0,2*Math.PI]).domain([0,1]);
    var gaugeCircleY = d3.scaleLinear().range([0,radius]).domain([0,radius]);

    // Scales for controlling the size of the clipping path.
    var waveScaleX = d3.scaleLinear().range([0,waveClipWidth]).domain([0,1]);
    var waveScaleY = d3.scaleLinear().range([0,waveHeight]).domain([0,1]);

    // Scales for controlling the position of the clipping path.
    var waveRiseScale = d3.scaleLinear()
        // The clipping area size is the height of the fill circle + the wave height, so we position the clip wave
        // such that the it will overlap the fill circle at all when at 0%, and will totally cover the fill
        // circle at 100%.
        .range([(fillCircleMargin+fillCircleRadius*2+waveHeight),(fillCircleMargin-waveHeight)])
        .domain([0,1]);
    var waveAnimateScale = d3.scaleLinear()
        .range([0, waveClipWidth-fillCircleRadius*2]) // Push the clip area one full wave then snap back.
        .domain([0,1]);

    // Scale for controlling the position of the text within the gauge.
    var textRiseScaleY = d3.scaleLinear()
        .range([fillCircleMargin+fillCircleRadius*2,(fillCircleMargin+textPixels*0.7)])
        .domain([0,1]);

    // Center the gauge within the parent SVG.
    var gaugeGroup = gauge.append("g")
        .attr('transform','translate('+locationX+','+locationY+')');

    // Draw the outer circle.
    var gaugeCircleArc = d3.arc()
        .startAngle(gaugeCircleX(0))
        .endAngle(gaugeCircleX(1))
        .outerRadius(gaugeCircleY(radius))
        .innerRadius(gaugeCircleY(radius-circleThickness));
    gaugeGroup.append("path")
        .attr("d", gaugeCircleArc)
        .style("fill", config.circleColor)
        .attr('transform','translate('+radius+','+radius+')');

    // Text where the wave does not overlap.
    var text1 = gaugeGroup.append("text")
        .text(textRounder(textStartValue) + percentText)
        .attr("class", "liquidFillGaugeText")
        .attr("text-anchor", "middle")
        .attr("font-size", textPixels + "px")
        .style("fill", config.textColor)
        .attr('transform','translate('+radius+','+textRiseScaleY(config.textVertPosition)+')');

    // The clipping wave area.
    var clipArea = d3.area()
        .x(function(d) { return waveScaleX(d.x); } )
        .y0(function(d) { return waveScaleY(Math.sin(Math.PI*2*config.waveOffset*-1 + Math.PI*2*(1-config.waveCount) + d.y*2*Math.PI));} )
        .y1(function(d) { return (fillCircleRadius*2 + waveHeight); } );
    var waveGroup = gaugeGroup.append("defs")
        .append("clipPath")
        .attr("id", "clipWave" + elementId);
    var wave = waveGroup.append("path")
        .datum(data)
        .attr("d", clipArea)
        .attr("T", 0);

    // The inner circle with the clipping wave attached.
    var fillCircleGroup = gaugeGroup.append("g")
        .attr("clip-path", "url(#clipWave" + elementId + ")");
    fillCircleGroup.append("circle")
        .attr("cx", radius)
        .attr("cy", radius)
        .attr("r", fillCircleRadius)
        .style("fill", config.waveColor);

    // Text where the wave does overlap.
    var text2 = fillCircleGroup.append("text")
        .text(textRounder(textStartValue) + percentText)
        .attr("class", "liquidFillGaugeText")
        .attr("text-anchor", "middle")
        .attr("font-size", textPixels + "px")
        .style("fill", config.waveTextColor)
        .attr('transform','translate('+radius+','+textRiseScaleY(config.textVertPosition)+')');

    // Make the value count up.
    if(config.valueCountUp){
        var textTween = function(){
            var i = d3.interpolate(this.textContent, textFinalValue);
            return function(t) { this.textContent = textRounder(i(t)) + percentText; }
        };
        text1.transition()
            .duration(config.waveRiseTime)
            .tween("text", textTween);
        text2.transition()
            .duration(config.waveRiseTime)
            .tween("text", textTween);
    }

    // Make the wave rise. wave and waveGroup are separate so that horizontal and vertical movement can be controlled independently.
    var waveGroupXPosition = fillCircleMargin+fillCircleRadius*2-waveClipWidth;
    if(config.waveRise){
        waveGroup.attr('transform','translate('+waveGroupXPosition+','+waveRiseScale(0)+')')
            .transition()
            .duration(config.waveRiseTime)
            .attr('transform','translate('+waveGroupXPosition+','+waveRiseScale(fillPercent)+')')
            .on("start", function(){ wave.attr('transform','translate(1,0)'); }); // This transform is necessary to get the clip wave positioned correctly when waveRise=true and waveAnimate=false. The wave will not position correctly without this, but it's not clear why this is actually necessary.
    } else {
        waveGroup.attr('transform','translate('+waveGroupXPosition+','+waveRiseScale(fillPercent)+')');
    }

    if(config.waveAnimate) animateWave();

    function animateWave() {
        wave.attr('transform','translate('+waveAnimateScale(wave.attr('T'))+',0)');
        wave.transition()
            .duration(config.waveAnimateTime * (1-wave.attr('T')))
            .ease(d3.easeLinear)
            .attr('transform','translate('+waveAnimateScale(1)+',0)')
            .attr('T', 1)
            .on('end', function(){
                wave.attr('T', 0);
                animateWave(config.waveAnimateTime);
            });
    }

    function GaugeUpdater(){
        this.update = function(value){
            var newFinalValue = parseFloat(value).toFixed(2);
            var textRounderUpdater = function(value){ return Math.round(value); };
            if(parseFloat(newFinalValue) != parseFloat(textRounderUpdater(newFinalValue))){
                textRounderUpdater = function(value){ return parseFloat(value).toFixed(1); };
            }
            if(parseFloat(newFinalValue) != parseFloat(textRounderUpdater(newFinalValue))){
                textRounderUpdater = function(value){ return parseFloat(value).toFixed(2); };
            }

            var textTween = function(){
                var i = d3.interpolate(this.textContent, parseFloat(value).toFixed(2));
                return function(t) { this.textContent = textRounderUpdater(i(t)) + percentText; }
            };

            text1.transition()
                .duration(config.waveRiseTime)
                .tween("text", textTween);
            text2.transition()
                .duration(config.waveRiseTime)
                .tween("text", textTween);

            var fillPercent = Math.max(config.minValue, Math.min(config.maxValue, value))/config.maxValue;
            var waveHeight = fillCircleRadius*waveHeightScale(fillPercent*100);
            var waveRiseScale = d3.scaleLinear()
                // The clipping area size is the height of the fill circle + the wave height, so we position the clip wave
                // such that the it will overlap the fill circle at all when at 0%, and will totally cover the fill
                // circle at 100%.
                .range([(fillCircleMargin+fillCircleRadius*2+waveHeight),(fillCircleMargin-waveHeight)])
                .domain([0,1]);
            var newHeight = waveRiseScale(fillPercent);
            var waveScaleX = d3.scaleLinear().range([0,waveClipWidth]).domain([0,1]);
            var waveScaleY = d3.scaleLinear().range([0,waveHeight]).domain([0,1]);
            var newClipArea;
            if(config.waveHeightScaling){
                newClipArea = d3.area()
                    .x(function(d) { return waveScaleX(d.x); } )
                    .y0(function(d) { return waveScaleY(Math.sin(Math.PI*2*config.waveOffset*-1 + Math.PI*2*(1-config.waveCount) + d.y*2*Math.PI));} )
                    .y1(function(d) { return (fillCircleRadius*2 + waveHeight); } );
            } else {
                newClipArea = clipArea;
            }

            var newWavePosition = config.waveAnimate?waveAnimateScale(1):0;
            wave.transition()
                .duration(0)
                .transition()
                .duration(config.waveAnimate?(config.waveAnimateTime * (1-wave.attr('T'))):(config.waveRiseTime))
                .ease(d3.easeLinear)
                .attr('d', newClipArea)
                .attr('transform','translate('+newWavePosition+',0)')
                .attr('T','1')
                .on("end", function(){
                    if(config.waveAnimate){
                        wave.attr('transform','translate('+waveAnimateScale(0)+',0)');
                        animateWave(config.waveAnimateTime);
                    }
                });
            waveGroup.transition()
                .duration(config.waveRiseTime)
                .attr('transform','translate('+waveGroupXPosition+','+newHeight+')')
        }
    }

    return new GaugeUpdater();
}
</script>
</body>
</html>

<style>
	.btnDebate{
		border: 2px solid steelblue;
		background-color: white;
		color: steelblue;
		cursor: pointer;
		outline: none;
		width: 18px;
		height: 18px;
		padding:4px 15.5px 19px 8px;
		border-radius: 50%;
		display: inline-block;
		font-size: 14px;
	}

	.btnDebateDash{
		display: inline-block;
		width: 5px;
		height: 100px;
		background-color: steelblue;
	}

	.Debatelabel {
		display: inline-block;
		width:40px;
		vertical-align: middle;;
		color: steelblue;
		cursor: pointer;
	}

	.btnDebateBelow{
		margin-top: -10px;
	}

	.btnSentiment {
		border: 1px solid steelblue;
		background-color: white;
		color: steelblue;
		padding: 8px;
		font-size: 12px !important;
		cursor: pointer;
		outline: none;
		width: 80px;
		border-radius: 5px;
	}

	.btnDebateSelected, .btnDebate:hover, .btnSentimentSelected, .btnSentiment:hover{
		background-color: steelblue;
		color: white;

	}

	.btnDebateSelected{
		box-shadow: 0px 0px 10px 0px steelblue !important;
	}

	.displayNumber{
		color:steelblue;
	}
	.displayNumberNegtive{
		color:red;
	}

	.CandidateImage, .seriesImage {
		border-radius: 50%;
	}

	.LineChartImage{
		border-radius: 50%;
		cursor: pointer;
		opacity: 0.3;
	}

	.LineChartImage:hover{
		opacity: 1;
	}

	.lineCircleTrump:hover {
		cursor: pointer;
	}

	.lineCircleHillary:hover {
		cursor: pointer;
	}

	.lineTextTrump:hover {
		cursor: pointer;
	}

	.lineTextHillary:hover{
		cursor: pointer;
	}

	.LineChartImageSelectedHillary{
		-webkit-box-shadow: 0px 0px 5px 5px orange;
		-moz-box-shadow: 0px 0px 5px 5px orange;
		box-shadow: 0px 0px 5px 5px orange;
		opacity: 1;
	}

	.LineChartImageSelectedTrump{
		-webkit-box-shadow: 0px 0px 5px 5px green;
		-moz-box-shadow: 0px 0px 5px 5px green;
		box-shadow: 0px 0px 5px 5px green;
		opacity: 1;
	}
	.btnLineChartLabel{
		color:grey;
		width: 60px;
		cursor: pointer;
		font-size: 12px;
		text-decoration: underline;
	}
	.btnLineChartLabelSelected{
		color:steelblue;
		width: 60px;
		cursor: pointer;
		font-size: 13px;
		font-weight: bold;
		text-decoration: none;
	}
	.btnLineChartLabel:hover{
		color:steelblue;
		font-size: 13px;
		font-weight: bold;
		cursor: pointer;
	}

	.tooltipPopup{
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
			border-radius: 5px;
        }

        .tooltipPopup .tooltipPopupInner::after {
            content: " ";
            position: absolute;
            top: 100%;
            left: 50%;
			margin-left: -10px;
            border-width: 10px;
            border-style: solid;
            border-color:  rgba(0, 0, 0, 0.7) transparent transparent transparent;
		}

	.lineCircleBar:hover{
		cursor: pointer;
		opacity: 0.1 !important;
	}

	.StatesSelected{
		background-color: rgba(70, 130, 180, 0.1);
	}

	.GreyOut{
		color:grey !important;
		border: grey !important;
	}
	.GreyOut:hover{
		background-color:steelblue !important;
		border: steelblue !important;
		color: white !important;
	}


	.btnDebate,
	#divPolaritySubjectivity,
	#divThemesSwing,
	.PolarityCell,
	.SubjectivityCell,
	.LineChartImage,
	.btnDebateDash,
	#lbHillaryPolarity,
	#lbTrumpPolarity
	{
		-webkit-transition: all 0.5s ease;
		-moz-transition: all 0.5s ease;
		-o-transition: all 0.5s ease;
		transition: all 0.5s ease;
	}

/* Customize the label (the container) */
.container {
  display: block;
  position: relative;
  padding-left: 35px;
  margin-bottom: 12px;
  cursor: pointer;
  font-size: 18px;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

/* Hide the browser's default checkbox */
.container input {
  position: absolute;
  opacity: 0;
  cursor: pointer;
  height: 0;
  width: 0;
}

/* Create a custom checkbox */
.checkmark {
  position: absolute;
  top: 0;
  left: 0;
  height: 20px;
  width: 20px;
  background-color: #eee;
}

/* On mouse-over, add a grey background color */
.container:hover input ~ .checkmark {
  background-color: #ccc;
}

/* When the checkbox is checked, add a blue background */
.container input:checked ~ .checkmark {
  background-color: steelblue;
}

/* Create the checkmark/indicator (hidden when not checked) */
.checkmark:after {
  content: "";
  position: absolute;
  display: none;
}

/* Show the checkmark when checked */
.container input:checked ~ .checkmark:after {
  display: block;
}

/* Style the checkmark/indicator */
.container .checkmark:after {
  left: 6px;
  top: 0px;
  width: 5px;
  height: 15px;
  border: solid white;
  border-width: 0 3px 3px 0;
  -webkit-transform: rotate(45deg);
  -ms-transform: rotate(45deg);
  transform: rotate(45deg);
}



* {box-sizing:border-box}

/* Fading animation */
.fade {
  -webkit-animation-name: fade;
  -webkit-animation-duration: 1.5s;
  animation-name: fade;
  animation-duration: 1.5s;
}

@-webkit-keyframes fade {
  from {opacity: .4}
  to {opacity: 1}
}

@keyframes fade {
  from {opacity: .4}
  to {opacity: 1}
}


.loader {
  border: 8px solid #f3f3f3;
  border-radius: 50%;
  border-top: 8px solid steelblue;
  border-bottom: 8px solid steelblue;
  width: 40px;
  height: 40px;
  -webkit-animation: spin 2s linear infinite; /* Safari */
  animation: spin 2s linear infinite;
}

/* Safari */
@-webkit-keyframes spin {
  0% { -webkit-transform: rotate(0deg); }
  100% { -webkit-transform: rotate(360deg); }
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

</style>

